#include <stdio.h>
#include <stdlib.h>
#include <sort.h>
#include <pairwise_align.h>
#include <string.h>

int *indexes[2];
int index_size;

typedef int score_t;

/* release_good_match:
 * Free the goot_match_t structure generated by Kernel 1 and Kernel 2
 * Note: You can still release a matrix that has not been through Kernel 2,
 *       there are not ill side effects.
 * Input:
 *     good_match_t *doomed - the structure to be freed
 * Output:
 *     None
 */

void release_good_match(good_match_t *doomed)
{
  if(doomed == NULL) return;
  free(doomed->goodScores);
  free(doomed->goodEnds[1]);
  free(doomed->goodEnds[0]);
  free(doomed->bestStarts[0]);
  free(doomed->bestStarts[1]);
  free(doomed->bestEnds[0]);
  free(doomed->bestEnds[1]);
  free(doomed->bestScores);
  for(int idx=0; idx<doomed->bestLength; idx++)
  {
    free(doomed->bestSeqs[idx].main);
    free(doomed->bestSeqs[idx].match);
  }
  free(doomed->bestSeqs);
  free(doomed);
}

int add_match(int *main_ends, int *match_ends, score_t *scores, int match_count, int max, int minSeparation, 
              score_t score, int main_end, int match_end)
{
  for(int idx=0; idx < match_count-1; idx++)
  {
    if(abs(main_end - main_ends[idx]) < minSeparation || abs(match_end - match_ends[idx]) < minSeparation)
    {
      if(score <= scores[idx])
      {
        return match_count;
      }
      else
      {
          for(int jdx=idx; jdx < match_count-1; jdx++)
          {
            scores[jdx] = scores[jdx+1];
            main_ends[jdx] = main_ends[jdx+1];
            match_ends[jdx] = match_ends[jdx+1];
          }
          match_count--;
      }
    }
  }
  main_ends[match_count] = main_end;
  match_ends[match_count] = match_end;
  scores[match_count] = score;
  match_count++;

  if(match_count == max)
  {
    int worst_keeper;
    int new_best_index=0;

    int *index_array = malloc(max*sizeof(int));
    int *sorted_array = malloc(max*sizeof(int));
    int *best_index = malloc(max*sizeof(int));

    memcpy(sorted_array, scores, sizeof(int)*max);
    index_sort(sorted_array, index_array, max);
    worst_keeper = (max/3)*2;

    for(int index_for_index=worst_keeper; index_for_index < max; index_for_index++)
    {
      best_index[new_best_index] = index_array[index_for_index];
      new_best_index++;
    }

    sort(best_index, new_best_index);
    for(int idx=0; idx < new_best_index; idx++)
    {
      scores[idx] = scores[best_index[idx]];
      main_ends[idx]=main_ends[best_index[idx]];
      match_ends[idx]=match_ends[best_index[idx]];
    }

    match_count = max/3;
    free(index_array);
    free(sorted_array);
    free(best_index);
  }

  return match_count;
}

#define max(x,y) ((x) > (y) ? (x) : (y) )
void score_diagnal(seq_data_t *seq_data, sim_matrix_t *sim_matrix, score_t *score_matrix[], int idx)
{
  int main_gap_score, match_gap_score, match_score;
  score_t cmp;
  int top, bottom;

  index_size=0;
  bottom = 1 > idx-seq_data->mainLen+1 ? 1 : idx-seq_data->mainLen+1;
  top = idx > seq_data->mainLen ? seq_data->mainLen : idx;

  for(int jdx=bottom; jdx < top; jdx++)
  {
    indexes[0][index_size] = jdx;
    indexes[1][index_size] = (idx - jdx);
    index_size++;
  }

#ifdef _OPENMP
#pragma omp parallel for private(main_gap_score,match_gap_score,match_score,cmp) shared(score_matrix,seq_data,sim_matrix,idx,indexes)
#endif
  for(int jdx=0; jdx < index_size; jdx++)
  {
    main_gap_score = score_matrix[(idx-1)%3][indexes[0][jdx]] -
      (sim_matrix->gapStart+sim_matrix->gapExtend);
    match_gap_score = score_matrix[(idx-1)%3][indexes[0][jdx]-1] -
      (sim_matrix->gapStart+sim_matrix->gapExtend);
    match_score = score_matrix[(idx-2)%3][indexes[0][jdx]-1] +
      sim_matrix->similarity[seq_data->main[indexes[0][jdx]]][seq_data->match[indexes[1][jdx]]];
    cmp = max(main_gap_score, match_gap_score);
    cmp = max(cmp,match_score);
    cmp = max(cmp, 0);
    score_matrix[idx%3][indexes[0][jdx]]=cmp;
  }
}

int harvest_diagnal(seq_data_t *seq_data, score_t *score_matrix[], score_t minScore, int minSeparation, 
                    int *main_ends,int *match_ends,int *scores, int potential_count, int target, int idx)
{
#ifdef _OPENMP
#pragma omp parallel for shared(score_matrix,minScore, seq_data, main_ends, match_ends, scores, potential_count, target, minSeparation, indexes)
#endif
  for(int jdx=0; jdx < index_size; jdx++)
  {
    if(score_matrix[idx%3][indexes[0][jdx]] > minScore)
    {
#ifdef _OPENMP
#pragma omp critical
#endif
      potential_count = add_match(main_ends, match_ends, scores, potential_count, target, minSeparation,
                                  score_matrix[idx%3][indexes[0][jdx]],
                                  indexes[0][jdx],indexes[1][jdx]);
    }
  }

  return potential_count;
}

good_match_t *pairwise_align(seq_data_t *seq_data, sim_matrix_t *sim_matrix, int minScore, int maxReports, int minSeparation)
{
  good_match_t *answer = malloc(sizeof(good_match_t));
  score_t *score_matrix[3];
  int target = maxReports * 3;
  int *main_ends = malloc(sizeof(int)*target);
  int *match_ends = malloc(sizeof(int)*target);
  int *scores = malloc(sizeof(int)*target);
  int *index_array;
  int *sort_array;
  int compare_a, worst, good_index;
  int potential_count=0;

  score_matrix[0] = malloc(sizeof(score_t)*seq_data->mainLen);
  score_matrix[1] = malloc(sizeof(score_t)*seq_data->mainLen);
  score_matrix[2] = malloc(sizeof(score_t)*seq_data->mainLen);

  memset(score_matrix[0], '\0', sizeof(score_t)*seq_data->mainLen);
  memset(score_matrix[1], '\0', sizeof(score_t)*seq_data->mainLen);
  memset(score_matrix[2], '\0', sizeof(score_t)*seq_data->mainLen);

  indexes[0] = malloc(sizeof(int)*seq_data->mainLen);
  indexes[1] = malloc(sizeof(int)*seq_data->mainLen);

  answer->simMatrix = sim_matrix;
  answer->seqData = seq_data;

  for(int idx=2; idx < (seq_data->mainLen*2)-2; idx++)
  {
    score_diagnal(seq_data,sim_matrix,score_matrix,idx);
    potential_count = harvest_diagnal(seq_data, score_matrix, minScore, minSeparation, main_ends, match_ends, scores, potential_count, target, idx);
  }

  free(indexes[0]);
  free(indexes[1]);

  index_array = malloc(sizeof(int) * potential_count);
  sort_array = malloc(sizeof(int) * potential_count);

  memcpy(sort_array, scores, potential_count * sizeof(int));
  index_sort(sort_array, index_array, potential_count);
  compare_a = potential_count - maxReports;
  worst = compare_a > 0 ? compare_a : 0;
  good_index = 0;
  answer->goodScores=malloc(sizeof(int)*maxReports);
  answer->goodEnds[0]=malloc(sizeof(int)*maxReports);
  answer->goodEnds[1]=malloc(sizeof(int)*maxReports);
  for(int idx = potential_count-1; idx >= worst; idx--)
  {
    answer->goodScores[good_index] = scores[index_array[idx]];
    answer->goodEnds[0][good_index] = main_ends[index_array[idx]];
    answer->goodEnds[1][good_index] = match_ends[index_array[idx]];
    good_index++;
  }
  answer->numReports = good_index;

  free(main_ends);
  free(match_ends);
  free(scores);
  free(index_array);
  free(sort_array);


  free(score_matrix[0]);
  free(score_matrix[1]);
  free(score_matrix[2]);
  return answer;
}

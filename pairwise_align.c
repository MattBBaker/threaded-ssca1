/*
*********************************************

Copyright 2008, UT-Battelle, LLC.
All rights Reserved.
See file LICENSING for licensing information.

*********************************************
*/

#include <stdio.h>
#include <stdlib.h>
#include <sort.h>
#include <pairwise_align.h>
#include <string.h>

#define USE_PTHREADS

#ifdef USE_PTHREADS
#include <pthread.h>
#endif

typedef struct
{
  int *goodEnds[2];
  int *goodScores;
  int report;
  int size;
} current_ends_t;

void compact_reports(current_ends_t *score_ends, int new_size)
{
}

/* consider adding this endpoint, possibly eliminating near by endpoints */

/*
void considerAdding(int score, int minSeparation, int main_index, int match_index,
                    int sortReports, int maxReports, int **goodEnds, int *goodScores)
*/
void considerAdding(int score, int minSeparation, int main_index, int match_index, 
                    int maxReports, current_ends_t *score_ends)
{
  int elements_to_copy;
  //printf("Considering\n");

  for(int r=score_ends->report-1; r>=0; r--)
  {
    if((main_index - score_ends->goodEnds[0][r]) >= minSeparation) break; // retain point r
    if(abs(match_index - score_ends->goodEnds[1][r]) >= minSeparation) continue;  // if not near by
    if(score_ends->goodScores[r] > score) return; // discard new point, maybe others

    // discard point r
    elements_to_copy = score_ends->report;

    for(int i = r; i < elements_to_copy; i++)
    {
      score_ends->goodScores[i]=score_ends->goodScores[i+1];
      score_ends->goodEnds[0][i]=score_ends->goodEnds[0][i+1];
      score_ends->goodEnds[1][i]=score_ends->goodEnds[1][i+1];
    }
    score_ends->report--;
  }

  // debug code, V[j] typically should not be this high

  //if(V[j] > 100)
  //  printf("adding element: %i at index: %i\n", V[j], *report);

  //printf("adding element: %i at index: %i\n", V[j], report);
  
  // add a new point
  score_ends->goodScores[score_ends->report]=score;
  score_ends->goodEnds[0][score_ends->report]=main_index;
  score_ends->goodEnds[1][score_ends->report]=match_index;
  score_ends->report++;

  // When the table is full, sort and discard all but the best end points.
  // Keep the table in entry order, just compact-out the discarded entries.
  if(score_ends->report == score_ends->size)
  {
    int worst_keeper;
    int new_best_index=0;

    int *index_array = malloc(score_ends->size*sizeof(int));
    int *sorted_array = malloc(score_ends->size*sizeof(int));
    int *best_index = malloc(score_ends->size*sizeof(int));

    sorted_array[0]=0;

    memcpy(sorted_array, score_ends->goodScores, sizeof(int)*score_ends->size);
    index_sort(sorted_array, index_array, score_ends->report);

    worst_keeper = score_ends->size - maxReports;
    //*minScore = sorted_array[worst_keeper] + 1;

    for(int index_for_index=worst_keeper; index_for_index < score_ends->size; index_for_index++)
    {
      best_index[new_best_index] = index_array[index_for_index];
      new_best_index++;
    }

    sort(best_index, new_best_index);
    for(int idx=0; idx < new_best_index; idx++)
    {
      score_ends->goodScores[idx] =score_ends->goodScores[best_index[idx]];
      score_ends->goodEnds[0][idx]=score_ends->goodEnds[0][best_index[idx]];
      score_ends->goodEnds[1][idx]=score_ends->goodEnds[1][best_index[idx]];
    }
    score_ends->report = maxReports;

    free(index_array);
    free(sorted_array);
    free(best_index);
  } 
}

/* release_good_match:
 * Free the goot_match_t structure generated by Kernel 1 and Kernel 2
 * Note: You can still release a matrix that has not been through Kernel 2,
 *       there are not ill side effects.
 * Input:
 *     good_match_t *doomed - the structure to be freed
 * Output:
 *     None
 */

void release_good_match(good_match_t *doomed)
{
  if(doomed==NULL) return;
  free(doomed->goodScores);
  free(doomed->goodEnds[1]);
  free(doomed->goodEnds[0]);
  free(doomed->bestStarts[0]);
  free(doomed->bestStarts[1]);
  free(doomed->bestEnds[0]);
  free(doomed->bestEnds[1]);
  free(doomed->bestScores);
  for(int idx=0; idx<doomed->bestLength; idx++)
  {
    free(doomed->bestSeqs[idx].main);
    free(doomed->bestSeqs[idx].match);
  }
  free(doomed->bestSeqs);
  free(doomed);
}

/* pairwise_align 
 * real meat of the program, this function finds codon similarities in seq_data using the matrix sim_matrix
 * Input:
 *   seq_data_t *seq_data     - Sequence data generated by genScalData()
 *   sim_matrix_t *sim_matrix - Codon similarity matrix generated by genSimMatrix()
 *   int minScore             - Minimum end point score, from the init_parameters() function
 *   int maxReports           - Maximum number of reports to keep, from the init_parameters() function
 *   int minSeparation        - Minimum end point seperation in codons, from the init_parameters() function
 *
 *  Output:
 *    good_matrix_t * - a matrix of good matches
 *       ->simMatrix  - a pointer to the sim_matrix_t used
 *       ->seqData    - a pointer to the seq_data_t used
 *	 ->goodEnds   - a [2][maxReports] matrix with main/match endpoints
 *       ->goodScores - a [maxReports] good scores for upto maxReports endpoints
 *       ->numReports - an integer, the number of reports represented
 */


#ifndef USE_PTHREADS
good_match_t *pairwise_align(seq_data_t *seq_data, sim_matrix_t *sim_matrix, int minScore, int maxReports, int minSeparation)
{
  good_match_t *answer = malloc(sizeof(good_match_t));
  int sortReports = maxReports * 3;
  int *index_array = malloc(sortReports * sizeof(int));
  int *sort_array = malloc(sortReports * sizeof(int));
  answer->simMatrix = sim_matrix;
  answer->seqData = seq_data;
  answer->goodEnds[0] = malloc(sizeof(int)*maxReports);
  answer->goodEnds[1] = malloc(sizeof(int)*maxReports);
  answer->goodScores = malloc(sizeof(int)*maxReports);

  memset(answer->goodEnds[0], 0, sizeof(int)*maxReports);
  memset(answer->goodEnds[1], 0, sizeof(int)*maxReports);
  memset(answer->goodScores, 0, sizeof(int)*maxReports);

  // With sufficiently large datasets these elements will cause
  // the program to segfault, blowing well past the stack.
  // So we need to malloc these bits.

  int *working_good_ends[2];
  int *working_good_scores = malloc(sizeof(int)*sortReports);

  working_good_ends[0] = malloc(sizeof(int *)*sortReports);
  working_good_ends[1] = malloc(sizeof(int *)*sortReports);

  memset(working_good_scores,0,sortReports*sizeof(int));
  answer->bestEnds[0] = NULL;
  answer->bestStarts[0] = NULL;
  answer->bestEnds[1] = NULL;
  answer->bestStarts[1] = NULL;
  answer->bestSeqs = NULL;
  answer->bestScores = NULL;

  int *mainSeq = seq_data->main;
  int *matchSeq = seq_data->match;
  int gapExtend = sim_matrix->gapExtend;
  int gapFirst = sim_matrix->gapStart + gapExtend;
  //int report = 0;
  int good_index = 0;
  int n = seq_data->mainLen;
  int m = seq_data->matchLen;

  int *V = malloc(seq_data->mainLen*sizeof(int));
  int *F = malloc(seq_data->matchLen*sizeof(int));

  int main_sequence, worst, W, G, E, Vp, compare_a, compare_b, i, j; 

  for(int idx = 0; idx < m; idx++)
  {
    V[idx] = 0;
    F[idx] = -gapFirst;
  }

  /* Loop over each codon in the mainSeq sequence, matching it with each codon   */
  /* in the matchSeq sequence, using the local-affine version of Smith-Waterman. */
  for(i=0; i<n; i++)
  {
    main_sequence=mainSeq[i];
    G = sim_matrix->similarity[main_sequence][matchSeq[0]];
    Vp = V[0];
    // Matlab has a builtin MAX function that can take arbitrary vectors, I have
    // to simulate that with compare_{a,b} and multiple compare.  
    compare_a = F[0] > G ? F[0] : G;
    V[0] = 0 > compare_a ? 0 : compare_a;
    F[0] = (F[0] - gapExtend > V[0] - gapFirst) ? F[0] - gapExtend : V[0] - gapFirst;
    E = V[0] - gapFirst;

    // match each mainSeq with each matchSeq codon to get a similarity weight
    for(j = 1; j < m; j++)
    {
      // match each mainSeq with each matchSeq codon to get a similarity weight
      W = sim_matrix->similarity[main_sequence][matchSeq[j]];
      // add the weight of the best match ending just before it
      G = Vp + W;
      // find the very best weight ending with this pair
      Vp = V[j]; // value of previous row
      // 4, we are comparing 4 values!  Ah ah!
      compare_a = 0 > E ? 0 : E;
      //compare_a = 0;
      compare_b = F[j] > compare_a ? F[j] : compare_a;
      V[j] = G > compare_b ? G : compare_b;
      //if(E > 0 && E > F[j] && E > G) printf("Bummer: E=%i, F[j]=%i, G=%i\n", E, F[j], G);
      // If score is good enough, this is an improvement, is not a skip,
      // and the next pair doesn't improve the match'
      if(V[j] >= minScore && W > 0 && V[j] == G && 
         (j == m-1 || i == n-1 || sim_matrix->similarity[mainSeq[i+1]][matchSeq[j+1]] <= 0))
      {
        // update goodScores/goodEnds
        considerAdding(V, minSeparation, i, j, i, j, sortReports, maxReports, working_good_ends, working_good_scores);
      }
      // find the best weight assuming a gap in mainSeq
      compare_a = E - gapExtend;
      compare_b = V[j] - gapFirst;
      E = compare_a > compare_b ? compare_a : compare_b;
      // find the best weight assuming a gap in matchSeq
      compare_a = F[j] - gapExtend;
      compare_b = V[j] - gapFirst;
      F[j] =  compare_a > compare_b ? compare_a : compare_b;
    }
  }

  memcpy(sort_array, working_good_scores, sortReports * sizeof(int));
  memset(index_array, 0, sizeof(int)*sortReports);
  index_sort(sort_array, index_array, report);
  compare_a = report - maxReports;
  worst = compare_a > 0 ? compare_a : 0;
  good_index = 0;
  for(int idx = report-1; idx >= worst; idx--)
  {
    answer->goodScores[good_index] = working_good_scores[index_array[idx]];
    answer->goodEnds[0][good_index] = working_good_ends[0][index_array[idx]];
    answer->goodEnds[1][good_index] = working_good_ends[1][index_array[idx]];
    good_index++;
  }

  free(V);
  free(F);
  free(working_good_scores);
  free(working_good_ends[0]);
  free(working_good_ends[1]);
  free(sort_array);
  free(index_array);
  answer->numReports = good_index;
  return answer;
}
#else

typedef struct
{
  seq_data_t *seq_data;
  sim_matrix_t *sim_matrix;
  current_ends_t *good_ends;
  int search_length;
  int max_match;
  int start_offset;
  int min_score;
  int min_separation;
  int max_reports;
} payload_t;

void *pairwise_worker(void *data)
{
  payload_t *in_data = (payload_t *)data;
  int *mainSeq = in_data->seq_data->main;
  int *matchSeq = in_data->seq_data->match;
  int maxReports = in_data->max_reports;
  int gapExtend = in_data->sim_matrix->gapExtend;
  int gapFirst = in_data->sim_matrix->gapStart + gapExtend;
  int n = in_data->seq_data->mainLen;
  int m = in_data->seq_data->matchLen;
  int main_sequence, W, G, E, Vp, compare_a, compare_b, i, j; 
  int *F = malloc(sizeof(int)*(in_data->search_length+in_data->max_match));
  int *V = malloc(sizeof(int)*(in_data->search_length+in_data->max_match));
  int minScore = in_data->min_score;
  int minSeparation = in_data->min_separation;
  current_ends_t *good_ends = in_data->good_ends;
  int start;
  int search_length;
  int primer_length;

  if(in_data->start_offset - in_data->max_match < 0)
  {
    start = 0;
    search_length = in_data->search_length + in_data->start_offset - in_data->max_match;
    primer_length = 0;
  }
  else
  {
    start = in_data->start_offset - in_data->max_match;
    search_length = in_data->search_length;
    primer_length = in_data->max_match;
  }
  
  for(int idx = 0; idx < in_data->search_length+in_data->max_match; idx++)
  {
    V[idx] = 0;
    F[idx] = -gapFirst;
  }

  for(i=0; i<n; i++)
  {
    main_sequence=mainSeq[i];
    G = in_data->sim_matrix->similarity[main_sequence][matchSeq[start]];
    Vp = V[0];
    // Matlab has a builtin MAX function that can take arbitrary vectors, I have
    // to simulate that with compare_{a,b} and multiple compare.  
    compare_a = F[0] > G ? F[0] : G;
    V[0] = 0 > compare_a ? 0 : compare_a;
    F[0] = (F[0] - gapExtend > V[0] - gapFirst) ? F[0] - gapExtend : V[0] - gapFirst;
    E = V[0] - gapFirst;

    // match each mainSeq with each matchSeq codon to get a similarity weight
    for(j = 1; j < search_length; j++)
    {
      // match each mainSeq with each matchSeq codon to get a similarity weight
      W = in_data->sim_matrix->similarity[main_sequence][matchSeq[j+start]];
      // add the weight of the best match ending just before it
      G = Vp + W;
      // find the very best weight ending with this pair
      Vp = V[j]; // value of previous row
      // 4, we are comparing 4 values!  Ah ah!
      compare_a = 0 > E ? 0 : E;
      //compare_a = 0;
      compare_b = F[j] > compare_a ? F[j] : compare_a;
      V[j] = G > compare_b ? G : compare_b;
      //if(E > 0 && E > F[j] && E > G) printf("Bummer: E=%i, F[j]=%i, G=%i\n", E, F[j], G);
      // If score is good enough, this is an improvement, is not a skip,
      // and the next pair doesn't improve the match'
      if((V[j] >= minScore && W > 0 && V[j] == G) && 
         (j == m-1 || i == n-1 || in_data->sim_matrix->similarity[mainSeq[i+1]][matchSeq[j+start+1]] <= 0) && j >= primer_length )
      {
        // update goodScores/goodEnds
        considerAdding(V[j], minSeparation, i, j+start, maxReports, good_ends);
      }
      // find the best weight assuming a gap in mainSeq
      compare_a = E - gapExtend;
      compare_b = V[j] - gapFirst;
      E = compare_a > compare_b ? compare_a : compare_b;
      // find the best weight assuming a gap in matchSeq
      compare_a = F[j] - gapExtend;
      compare_b = V[j] - gapFirst;
      F[j] =  compare_a > compare_b ? compare_a : compare_b;
    }
  }
  free(V);
  free(F);

  return NULL;
}

good_match_t *pairwise_align(seq_data_t *seq_data, sim_matrix_t *sim_matrix, int minScore, int maxReports, int minSeparation, int threads)
{
  int sortReports = maxReports * 3;
  int max_values=0;
  int **index_array = malloc(threads * sizeof(int *));
  int **sort_array = malloc(threads * sizeof(int *));
  good_match_t *answer;

  int min_size = (seq_data->mainLen/threads);
  int big_runs = (seq_data->mainLen%threads);

  pthread_t *pairwise_threads = malloc(sizeof(pthread_t)*threads);
  payload_t **payloads = malloc(sizeof(payload_t *)*threads);
  payload_t staging;

  memset(&staging, '\0', sizeof(payload_t));
  staging.max_reports = maxReports;
  staging.sim_matrix = sim_matrix;
  staging.seq_data = seq_data;
  staging.min_score = minScore;
  staging.min_separation = minSeparation;
  staging.max_match = sim_matrix->matchLimit;

  answer->bestEnds[0] = NULL;
  answer->bestStarts[0] = NULL;
  answer->bestEnds[1] = NULL;
  answer->bestStarts[1] = NULL;
  answer->bestSeqs = NULL;
  answer->bestScores = NULL;

  int worst, compare_a;
  int good_index = 0;

  for(int idx=0; idx < big_runs; idx++)
  {
    payloads[idx] = malloc(sizeof(payload_t));
    memcpy(payloads[idx], &staging, sizeof(payload_t));
    payloads[idx]->start_offset=(min_size+1)*idx;
    payloads[idx]->search_length=min_size+1;
    payloads[idx]->good_ends = malloc(sizeof(current_ends_t));
    payloads[idx]->good_ends->size = sortReports;
    payloads[idx]->good_ends->report = 0;
    payloads[idx]->good_ends->goodScores = malloc(sizeof(int)*sortReports);
    payloads[idx]->good_ends->goodEnds[0] = malloc(sizeof(int)*sortReports);
    payloads[idx]->good_ends->goodEnds[1] = malloc(sizeof(int)*sortReports);
    pthread_create(&(pairwise_threads[idx]),NULL, pairwise_worker, payloads[idx]);
  }

  for(int idx=big_runs; idx < threads; idx++)
  {
    payloads[idx] = malloc(sizeof(payload_t));
    memcpy(payloads[idx], &staging, sizeof(payload_t));
    payloads[idx]->start_offset=((min_size+1)*big_runs)+(min_size*(idx-big_runs));
    payloads[idx]->search_length=min_size;
    payloads[idx]->good_ends = malloc(sizeof(current_ends_t));
    payloads[idx]->good_ends->size = sortReports;
    payloads[idx]->good_ends->report = 0;
    payloads[idx]->good_ends->goodScores = malloc(sizeof(int)*sortReports);
    payloads[idx]->good_ends->goodEnds[0] = malloc(sizeof(int)*sortReports);
    payloads[idx]->good_ends->goodEnds[1] = malloc(sizeof(int)*sortReports);
    pthread_create(&(pairwise_threads[idx]),NULL, pairwise_worker, payloads[idx]);
  }

  for(int idx=0; idx < threads; idx++)
  {
    pthread_join(pairwise_threads[idx], NULL);
    index_array[idx] = malloc(sortReports * sizeof(int));
    sort_array[idx] = malloc(sortReports * sizeof(int));
    memset(sort_array[idx], 0, sizeof(int)*sortReports);
    memcpy(sort_array[idx], payloads[idx]->good_ends->goodScores, payloads[idx]->good_ends->report * sizeof(int));
    memset(index_array[idx], 0, sizeof(int)*sortReports);
    index_sort(sort_array[idx], index_array[idx], payloads[idx]->good_ends->report);
    max_values+=payloads[idx]->good_ends->report;
  }

  answer = malloc(sizeof(good_match_t));
  answer->simMatrix = sim_matrix;
  answer->seqData = seq_data;
  answer->goodEnds[0] = malloc(sizeof(int)*maxReports);
  answer->goodEnds[1] = malloc(sizeof(int)*maxReports);
  answer->goodScores = malloc(sizeof(int)*maxReports);

  memset(answer->goodEnds[0], 0, sizeof(int)*maxReports);
  memset(answer->goodEnds[1], 0, sizeof(int)*maxReports);
  memset(answer->goodScores, 0, sizeof(int)*maxReports);


  if(max_values > maxReports) max_values = maxReports;

  for(int idx=0; idx < max_values; idx++)
  {
    good_index = 0;
    compare_a = sort_array[0][payloads[0]->good_ends->report-1];
    for(int tdx=1; tdx < threads; tdx++)
    {
      if(payloads[tdx]->good_ends->report == 0) continue;
      if(sort_array[tdx][payloads[tdx]->good_ends->report-1] > compare_a)
      {
        compare_a = sort_array[tdx][payloads[tdx]->good_ends->report-1];
        good_index = tdx;
      }
    }
    answer->goodScores[idx] = payloads[good_index]->good_ends->goodScores[index_array[good_index][payloads[good_index]->good_ends->report-1]];
    answer->goodEnds[0][idx] = payloads[good_index]->good_ends->goodEnds[0][index_array[good_index][payloads[good_index]->good_ends->report-1]];
    answer->goodEnds[1][idx] = payloads[good_index]->good_ends->goodEnds[1][index_array[good_index][payloads[good_index]->good_ends->report-1]];
    payloads[good_index]->good_ends->report--;
  }

  /*
  memcpy(sort_array, staging.good_ends->goodScores, sortReports * sizeof(int));
  memset(index_array, 0, sizeof(int)*sortReports);
  index_sort(sort_array, index_array, staging.good_ends->report);
  compare_a = staging.good_ends->report - maxReports;
  worst = compare_a > 0 ? compare_a : 0;
  good_index = 0;

  for(int idx = staging.good_ends->report-1; idx >= worst; idx--)
  {
    answer->goodScores[good_index] = staging.good_ends->goodScores[index_array[idx]];
    answer->goodEnds[0][good_index] = staging.good_ends->goodEnds[0][index_array[idx]];
    answer->goodEnds[1][good_index] = staging.good_ends->goodEnds[1][index_array[idx]];
    good_index++;
  }
  */

  for(int idx=0; idx < threads; idx++)
  {
    free(payloads[idx]->good_ends->goodScores);
    free(payloads[idx]->good_ends->goodEnds[0]);
    free(payloads[idx]->good_ends->goodEnds[1]);
    free(payloads[idx]->good_ends);
    free(payloads[idx]);
  }
  free(payloads);
  free(sort_array);
  free(index_array);
  answer->numReports = max_values;
  return answer;
}
#endif

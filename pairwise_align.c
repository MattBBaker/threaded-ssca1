/*
*********************************************

Copyright 2008, UT-Battelle, LLC.
All rights Reserved.
See file LICENSING for licensing information.

*********************************************
*/

#include <stdio.h>
#include <stdlib.h>
#include <sort.h>
#include <pairwise_align.h>
#include <string.h>
#include <util.h>
#include <assert.h>

#ifdef _OPENMP
#include <omp.h>
#else
#define omp_get_max_threads() 1
#define omp_get_thread_num() 0
#endif

typedef struct
{
  index_t *goodEnds[2];
  score_t *goodScores;
  int report;
  int size;
  score_t min_score;
} current_ends_t;

index_t unsigned_abs_diff(index_t A, index_t B) {
  return (A > B) ? (A - B) : (B - A);
}

index_t consider=0;
index_t compact=0;

void considerAdding(score_t score, int minSeparation, index_t main_index, index_t match_index,
                    int maxReports, current_ends_t *score_ends) {
  consider++;
  //first scan the list to see if there is a match already that is closer
  for(int idx=0; idx < score_ends->report; idx++){
    if(unsigned_abs_diff(score_ends->goodEnds[0][idx], main_index) < minSeparation || unsigned_abs_diff(score_ends->goodEnds[1][idx], match_index) < minSeparation) {
      if(score_ends->goodScores[idx] < score) {
        score_ends->goodEnds[0][idx] = main_index;
        score_ends->goodEnds[1][idx] = match_index;
        score_ends->goodScores[idx] = score;
        return;
      } else {
        return;
      }
    }
  }
  //enlarge if needed
  if(score_ends->report == score_ends->size) {
    compact++;
    index_t worst_keeper, new_best_index=0;
    index_t *index_array = NULL;
    score_t *sorted_array = NULL;
    index_t *best_index = NULL;

    if(index_array == NULL) index_array = (index_t *)malloc(score_ends->size*sizeof(index_t));
    if(sorted_array == NULL) sorted_array = (score_t *)malloc(score_ends->size*sizeof(score_t));
    if(best_index == NULL) best_index = (index_t *)malloc(score_ends->size*sizeof(index_t));

    memcpy(sorted_array, score_ends->goodScores, sizeof(score_t)*score_ends->report);
    index_sort(sorted_array, index_array, score_ends->report);

    worst_keeper = score_ends->size - maxReports;
    score_ends->min_score = score_ends->goodScores[best_index[worst_keeper]];
    printf("minScore is now %i\n", (int)score_ends->min_score);

    for(int index_for_index=worst_keeper; index_for_index < score_ends->size; index_for_index++) {
      best_index[new_best_index] = index_array[index_for_index];
      new_best_index++;
    }

    sort(best_index, new_best_index);
    for(int idx=0; idx < new_best_index; idx++) {
      score_ends->goodScores[idx] =score_ends->goodScores[best_index[idx]];
      score_ends->goodEnds[0][idx]=score_ends->goodEnds[0][best_index[idx]];
      score_ends->goodEnds[1][idx]=score_ends->goodEnds[1][best_index[idx]];
    }
    score_ends->report = maxReports;
    free(index_array);
    free(sorted_array);
    free(best_index);
  }

  score_ends->goodEnds[0][score_ends->report] = main_index;
  score_ends->goodEnds[1][score_ends->report] = match_index;
  score_ends->goodScores[score_ends->report] = score;
  score_ends->report++;
}

/* release_good_match:
 * Free the goot_match_t structure generated by Kernel 1 and Kernel 2
 * Note: You can still release a matrix that has not been through Kernel 2,
 *       there are not ill side effects.
 * Input:
 *     good_match_t *doomed - the structure to be freed
 * Output:
 *     None
 */

void release_good_match(good_match_t *doomed)
{
  if(doomed==NULL) return;
  free(doomed->goodScores);
  free(doomed->goodEnds[1]);
  free(doomed->goodEnds[0]);
  free(doomed->bestStarts[0]);
  free(doomed->bestStarts[1]);
  free(doomed->bestEnds[0]);
  free(doomed->bestEnds[1]);
  free(doomed->bestScores);
  for(int idx=0; idx<doomed->bestLength; idx++)
  {
    free(doomed->bestSeqs[idx].main);
    free(doomed->bestSeqs[idx].match);
  }
  free(doomed->bestSeqs);
  free(doomed);
}

/* pairwise_align 
 * real meat of the program, this function finds codon similarities in seq_data using the matrix sim_matrix
 * Input:
 *   seq_data_t *seq_data     - Sequence data generated by genScalData()
 *   sim_matrix_t *sim_matrix - Codon similarity matrix generated by genSimMatrix()
 *   int minScore             - Minimum end point score, from the init_parameters() function
 *   int maxReports           - Maximum number of reports to keep, from the init_parameters() function
 *   int minSeparation        - Minimum end point seperation in codons, from the init_parameters() function
 *
 *  Output:
 *    good_matrix_t * - a matrix of good matches
 *       ->simMatrix  - a pointer to the sim_matrix_t used
 *       ->seqData    - a pointer to the seq_data_t used
 *	 ->goodEnds   - a [2][maxReports] matrix with main/match endpoints
 *       ->goodScores - a [maxReports] good scores for upto maxReports endpoints
 *       ->numReports - an integer, the number of reports represented
 */

#define index2d(x,y,stride) ((y) + ((x) * (stride)))

//void *pairwise_worker(void *data) {
good_match_t *pairwise_align(seq_data_t *seq_data, sim_matrix_t *sim_matrix, int minScore, int maxReports, int minSeparation) {
  const int sortReports = maxReports * 10;
  const codon_t *mainSeq = seq_data->main;
  const codon_t *matchSeq = seq_data->match;
  const score_t gapExtend = sim_matrix->gapExtend;
  const score_t gapFirst = sim_matrix->gapStart + gapExtend;
  int max_threads = omp_get_max_threads();
  printf("Today we will be using %i threads\n", max_threads);

  //current_ends_t *good_ends = (current_ends_t *)malloc(sizeof(current_ends_t));
  current_ends_t **good_ends = (current_ends_t **)malloc(sizeof(current_ends_t *)*max_threads);
#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(int jdx=0; jdx < max_threads; jdx++) {
    int idx = omp_get_thread_num();
    good_ends[idx] = (current_ends_t *)malloc(sizeof(current_ends_t));
    good_ends[idx]->size = sortReports;
    good_ends[idx]->report = 0;
    good_ends[idx]->goodScores = (score_t *)malloc(sizeof(score_t)*sortReports);
    good_ends[idx]->goodEnds[0] = (index_t *)malloc(sizeof(index_t)*sortReports);
    good_ends[idx]->goodEnds[1] = (index_t *)malloc(sizeof(index_t)*sortReports);
    good_ends[idx]->min_score = minScore;
  }

  score_t *score_matrix = (score_t *)malloc(sizeof(score_t)*3*seq_data->matchLen);
  assert(score_matrix != NULL);
  score_t *match_gap_matrix = (score_t *)malloc(sizeof(score_t)*2*seq_data->matchLen);
  assert(match_gap_matrix != NULL);
  score_t *main_gap_matrix = (score_t *)malloc(sizeof(score_t)*2*seq_data->matchLen);
  assert(main_gap_matrix != NULL);
  printf("touching score\n");
  touch_memory(score_matrix, sizeof(score_t)*3*seq_data->matchLen);
  printf("touching match\n");
  touch_memory(match_gap_matrix, sizeof(score_t)*2*seq_data->mainLen);
  printf("touching main\n");
  touch_memory(main_gap_matrix, sizeof(score_t)*2*seq_data->matchLen);
  printf("done touching memory\n");
  index_t score_start, score_end;
  score_t G, W, E, F, cmp_a, cmp_b;
  index_t m, n;
  int max_values=0;
  index_t *index_array;
  score_t *sort_array;
  good_match_t *answer;

  W = sim_matrix->similarity[mainSeq[0]][matchSeq[0]];
  score_matrix[index2d(0,0,seq_data->matchLen)] = 0 > W ? 0 : W;
  main_gap_matrix[0] = -gapFirst + W;
  match_gap_matrix[0] = -gapFirst + W;

  W = sim_matrix->similarity[mainSeq[0]][matchSeq[1]];
  G = W;
  E = main_gap_matrix[index2d(0,0,seq_data->matchLen)];
  cmp_a = 0 > E ? 0 : E;
  cmp_a = cmp_a > G ? cmp_a : G;
  score_matrix[index2d(1,1,seq_data->matchLen)] = cmp_a;
  cmp_a = E - gapExtend;
  cmp_b = G - gapFirst;
  main_gap_matrix[index2d(1,0,seq_data->matchLen)] = cmp_a > cmp_b ? cmp_a : cmp_b;
  match_gap_matrix[index2d(1,0,seq_data->matchLen)] = -gapFirst > cmp_b ? -gapFirst : cmp_b;

  W = sim_matrix->similarity[mainSeq[1]][matchSeq[0]];
  G = W;
  F = match_gap_matrix[index2d(0,0,seq_data->matchLen)];
  cmp_a = 0 > F ? 0 : F;
  cmp_a = cmp_a > G ? cmp_a : G;
  score_matrix[index2d(1,0,seq_data->matchLen)] = cmp_a;
  cmp_a = F - gapExtend;
  cmp_b = G - gapFirst;
  main_gap_matrix[index2d(1,1,seq_data->matchLen)] = -gapFirst > cmp_b ? -gapFirst : cmp_b;
  match_gap_matrix[index2d(1,1,seq_data->matchLen)] = cmp_a > cmp_b ? cmp_a : cmp_b;

  for(index_t idx=2; idx < seq_data->matchLen * 2; idx++) {
    //minScore = good_ends->min_score;
    score_start = idx > (seq_data->matchLen - 1) ? (idx-(seq_data->matchLen-1)) : 0;
    score_end = idx < (seq_data->matchLen-1) ? (idx) : (seq_data->matchLen-1);
    if(idx < seq_data->matchLen) {
      m = 0;
      n = idx;
      W = sim_matrix->similarity[mainSeq[m]][matchSeq[n]];
      G = W;
      F = match_gap_matrix[index2d((idx-1)%2,n-1,seq_data->matchLen)];
      cmp_a = F > 0 ? F : 0;
      cmp_a = cmp_a > G ? cmp_a : G;
      score_matrix[index2d((idx%3),m,seq_data->matchLen)] = cmp_a;
      if((W > 0 && cmp_a > minScore && cmp_a == G) &&
         ((m == seq_data->matchLen - 1) || (n == seq_data->matchLen - 1) ||
          (sim_matrix->similarity[mainSeq[m+1]][matchSeq[n+1]] <= 0))) {
        considerAdding(score_matrix[index2d((idx%3),m,seq_data->matchLen)], minSeparation, m, n, maxReports, good_ends[0]);
      }
      cmp_a = F - gapExtend;
      cmp_b = G - gapFirst;
      match_gap_matrix[index2d(idx%2,n,seq_data->matchLen)] = cmp_a > cmp_b ? cmp_a : cmp_b;
      score_start = score_start+1;

      m = idx;
      n = 0;
      E = main_gap_matrix[index2d((idx-1)%2,m-1,seq_data->matchLen)];
      cmp_a = E > 0 ? E : 0;
      cmp_a = cmp_a > G ? cmp_a : G;
      score_matrix[index2d((idx%3),m,seq_data->matchLen)] = cmp_a;
      if((cmp_a > minScore && W > 0 && cmp_a == G) &&
         ((m == seq_data->matchLen - 1) || (n == seq_data->matchLen - 1) ||
          (sim_matrix->similarity[mainSeq[m+1]][matchSeq[n+1]] <= 0))) {
        considerAdding(score_matrix[index2d((idx%3),m,seq_data->matchLen)], minSeparation, m, n, maxReports, good_ends[0]);
      }
      cmp_a = E - gapExtend;
      cmp_b = G - gapFirst;
      main_gap_matrix[index2d(idx%2,m,seq_data->matchLen)] = cmp_a > cmp_b ? cmp_a : cmp_b;
      score_end = score_end - 1;
    }

#ifdef _OPENMP
#pragma omp parallel for private(m,n,W,G,F,E,cmp_a,cmp_b) firstprivate(idx, score_matrix, sim_matrix, main_gap_matrix, match_gap_matrix, seq_data, minScore, minSeparation, maxReports) shared(good_ends) schedule(static)
#endif
    for(index_t antidiagonal = score_start; antidiagonal <= score_end; antidiagonal++) {
      //good_ends_t *my_end = good_ends[omp_get_thread_num()];
      m = antidiagonal;
      n = idx - m;

      //W is the score for the current match. G is the current match added to the previous score.
      //F is the score with a gap in the match sequence and E is the score with a gap in the main sequence
      W = sim_matrix->similarity[mainSeq[m]][matchSeq[n]];
      G = score_matrix[index2d(((idx-2)%3),m-1,seq_data->matchLen)] + W;
      F = match_gap_matrix[index2d((idx-1)%2,n-1,seq_data->matchLen)];
      E = main_gap_matrix[index2d((idx-1)%2,m-1,seq_data->matchLen)];
      cmp_a = 0;
      cmp_a = cmp_a > E ? cmp_a : E;
      cmp_a = cmp_a > F ? cmp_a : F;
      cmp_a = cmp_a > G ? cmp_a : G;
      score_matrix[index2d((idx%3),m,seq_data->matchLen)] = cmp_a;
      if((cmp_a > minScore && W > 0 && cmp_a == G) &&
         ((m == seq_data->matchLen - 1) || (n == seq_data->matchLen - 1) ||
          (sim_matrix->similarity[mainSeq[m+1]][matchSeq[n+1]] <= 0))) {
#ifdef _OPENMP
        //#pragma omp critical
#endif
        considerAdding(score_matrix[index2d((idx%3),m,seq_data->matchLen)], minSeparation, m, n, maxReports, good_ends[omp_get_thread_num()]);
      }
      //cmp_b covers a new gap, while cmp_a covers extending a previous gap.
      cmp_a = E - gapExtend;
      cmp_b = G - gapFirst;
      main_gap_matrix[index2d((idx)%2,m,seq_data->matchLen)] = cmp_a > cmp_b ? cmp_a : cmp_b;
      cmp_a = F - gapExtend;
      match_gap_matrix[index2d((idx)%2,n,seq_data->matchLen)] = cmp_a > cmp_b ? cmp_a : cmp_b;
    }
  }

  answer = (good_match_t*)malloc(sizeof(good_match_t));
  answer->simMatrix = sim_matrix;
  answer->seqData = seq_data;
  answer->goodEnds[0] = (index_t*)malloc(sizeof(index_t)*maxReports);
  answer->goodEnds[1] = (index_t*)malloc(sizeof(index_t)*maxReports);
  answer->goodScores = (score_t*)malloc(sizeof(score_t)*maxReports);

  memset(answer->goodEnds[0], 0, sizeof(index_t)*maxReports);
  memset(answer->goodEnds[1], 0, sizeof(index_t)*maxReports);
  memset(answer->goodScores, 0, sizeof(score_t)*maxReports);

  answer->bestEnds[0] = NULL;
  answer->bestStarts[0] = NULL;
  answer->bestEnds[1] = NULL;
  answer->bestStarts[1] = NULL;
  answer->bestSeqs = NULL;
  answer->bestScores = NULL;

  index_array = (index_t*)malloc(good_ends[0]->size * sizeof(index_t) * max_threads);
  sort_array = (score_t*)malloc(good_ends[0]->size * sizeof(score_t) * max_threads);
  memset(sort_array, 0, sizeof(score_t)*good_ends[0]->size * max_threads);
  memset(index_array, 0, sizeof(index_t)*good_ends[0]->size * max_threads);
  index_t copied=0;
  for(int idx=0; idx < max_threads; idx++) {
    memcpy(sort_array+copied, good_ends[idx]->goodScores, good_ends[idx]->report * sizeof(score_t));
    copied += good_ends[idx]->report;
  }
  index_sort(sort_array, index_array, copied);

  max_values=copied;

  if(max_values > maxReports) max_values = maxReports;

  int thread_idx, entry_idx;
  int entry;
  for(int idx=0; idx < max_values; idx++) {
    entry = index_array[copied-(idx+1)];
    thread_idx = 0;
    entry_idx = 0;
    while( entry >= good_ends[thread_idx]->report ) {
      entry -= good_ends[thread_idx]->report;
      thread_idx++;
    } 
    answer->goodScores[idx] = good_ends[thread_idx]->goodScores[entry];
    answer->goodEnds[0][idx] = good_ends[thread_idx]->goodEnds[0][entry];
    answer->goodEnds[1][idx] = good_ends[thread_idx]->goodEnds[1][entry];
  }

  printf("Consider may be hit %lu times.\n", seq_data->matchLen * seq_data->matchLen);
  printf("Consider was it %lu times\nCompacted %lu times\n", consider, compact);
  float consider_pct, compact_pct;
  consider_pct = (float)(consider) / (float)(seq_data->matchLen * seq_data->matchLen);
  compact_pct = (float)(compact) / (float)(seq_data->matchLen * seq_data->matchLen);
  printf("Percentage of iterations were a score was considered: %f\nPercentage of iterations where scores were compacted: %f\n", consider_pct * 100.0, compact_pct * 100.0);

  free(score_matrix);
  free(main_gap_matrix);
  free(match_gap_matrix);
  for(int idx=0; idx < max_threads; idx++) {
    free(good_ends[idx]->goodScores);
    free(good_ends[idx]->goodEnds[0]);
    free(good_ends[idx]->goodEnds[1]);
    free(good_ends[idx]);
  }
  free(good_ends);

  free(sort_array);
  free(index_array);
  answer->numReports = max_values;
  return answer;
}

/*
*********************************************

Copyright 2008, UT-Battelle, LLC.
All rights Reserved.
See file LICENSING for licensing information.

*********************************************
*/

#include <stdio.h>
#include <stdlib.h>
#include <sort.h>
#include <pairwise_align.h>
#include <string.h>

/* consider adding this endpoint, possibly eliminating near by endpoints */

void considerAdding(int V[], int *minScore, int *report, int minSeparation, int i, int j, int sortReports, int maxReports, int **goodEnds, int *goodScores)
{
  int elements_to_copy;

  for(int r=(*report)-1; r>=0; r--)
  {
    if((i - goodEnds[0][r]) >= minSeparation) break; // retain point r
    if(abs(j - goodEnds[1][r]) >= minSeparation) continue;  // if not near by
    if(goodScores[r] > V[j]) return; // discard new point, maybe others

    // discard point r
    elements_to_copy = (*report);

    for(int i = r; i < elements_to_copy; i++)
    {
      goodScores[i]=goodScores[i+1];
      goodEnds[0][i]=goodEnds[0][i+1];
      goodEnds[1][i]=goodEnds[1][i+1];
    }
    (*report)--;
  }

  // debug code, V[j] typically should not be this high

  //if(V[j] > 100)
  //  printf("adding element: %i at index: %i\n", V[j], *report);
  
  // add a new point
  goodScores[*report]=V[j];
  goodEnds[0][*report]=i;
  goodEnds[1][*report]=j;
  (*report)++;

  // When the table is full, sort and discard all but the best end points.
  // Keep the table in entry order, just compact-out the discarded entries.
  if(*report == sortReports)
  {
    int worst_keeper;
    int new_best_index=0;

    int *index_array = malloc(sortReports*sizeof(int));
    int *sorted_array = malloc(sortReports*sizeof(int));
    int *best_index = malloc(sortReports*sizeof(int));

    sorted_array[0]=0;

    memcpy(sorted_array, goodScores, sizeof(int)*sortReports);
    index_sort(sorted_array, index_array, *report);

    worst_keeper = sortReports - maxReports;
    *minScore = sorted_array[worst_keeper] + 1;

    for(int index_for_index=worst_keeper; index_for_index < sortReports; index_for_index++)
    {
      best_index[new_best_index] = index_array[index_for_index];
      new_best_index++;
    }

    sort(best_index, new_best_index);
    for(int idx=0; idx < new_best_index; idx++)
    {
      goodScores[idx] = goodScores[best_index[idx]];
      goodEnds[0][idx]=goodEnds[0][best_index[idx]];
      goodEnds[1][idx]=goodEnds[1][best_index[idx]];
    }
    *report = maxReports;

    free(index_array);
    free(sorted_array);
    free(best_index);
  } 
}

/* release_good_match:
 * Free the goot_match_t structure generated by Kernel 1 and Kernel 2
 * Note: You can still release a matrix that has not been through Kernel 2,
 *       there are not ill side effects.
 * Input:
 *     good_match_t *doomed - the structure to be freed
 * Output:
 *     None
 */

void release_good_match(good_match_t *doomed)
{
  if(doomed==NULL) return;
  free(doomed->goodScores);
  free(doomed->goodEnds[1]);
  free(doomed->goodEnds[0]);
  free(doomed->bestStarts[0]);
  free(doomed->bestStarts[1]);
  free(doomed->bestEnds[0]);
  free(doomed->bestEnds[1]);
  free(doomed->bestScores);
  for(int idx=0; idx<doomed->bestLength; idx++)
  {
    free(doomed->bestSeqs[idx].main);
    free(doomed->bestSeqs[idx].match);
  }
  free(doomed->bestSeqs);
  free(doomed);
}

/* pairwise_align 
 * real meat of the program, this function finds codon similarities in seq_data using the matrix sim_matrix
 * Input:
 *   seq_data_t *seq_data     - Sequence data generated by genScalData()
 *   sim_matrix_t *sim_matrix - Codon similarity matrix generated by genSimMatrix()
 *   int minScore             - Minimum end point score, from the init_parameters() function
 *   int maxReports           - Maximum number of reports to keep, from the init_parameters() function
 *   int minSeparation        - Minimum end point seperation in codons, from the init_parameters() function
 *
 *  Output:
 *    good_matrix_t * - a matrix of good matches
 *       ->simMatrix  - a pointer to the sim_matrix_t used
 *       ->seqData    - a pointer to the seq_data_t used
 *	 ->goodEnds   - a [2][maxReports] matrix with main/match endpoints
 *       ->goodScores - a [maxReports] good scores for upto maxReports endpoints
 *       ->numReports - an integer, the number of reports represented
 */

good_match_t *pairwise_align(seq_data_t *seq_data, sim_matrix_t *sim_matrix, int minScore, int maxReports, int minSeparation)
{
  good_match_t *answer = malloc(sizeof(good_match_t));
  int sortReports = maxReports * 3;
  int *index_array = malloc(sortReports * sizeof(int));
  int *sort_array = malloc(sortReports * sizeof(int));
  answer->simMatrix = sim_matrix;
  answer->seqData = seq_data;
  answer->goodEnds[0] = malloc(sizeof(int)*maxReports);
  answer->goodEnds[1] = malloc(sizeof(int)*maxReports);
  answer->goodScores = malloc(sizeof(int)*maxReports);

  memset(answer->goodEnds[0], 0, sizeof(int)*maxReports);
  memset(answer->goodEnds[1], 0, sizeof(int)*maxReports);
  memset(answer->goodScores, 0, sizeof(int)*maxReports);

  // With sufficiently large datasets these elements will cause
  // the program to segfault, blowing well past the stack.
  // So we need to malloc these bits.

  int *working_good_ends[2];
  int *working_good_scores = malloc(sizeof(int)*sortReports);

  working_good_ends[0] = malloc(sizeof(int *)*sortReports);
  working_good_ends[1] = malloc(sizeof(int *)*sortReports);

  memset(working_good_scores,0,sortReports*sizeof(int));
  answer->bestEnds[0] = NULL;
  answer->bestStarts[0] = NULL;
  answer->bestEnds[1] = NULL;
  answer->bestStarts[1] = NULL;
  answer->bestSeqs = NULL;
  answer->bestScores = NULL;

  int *mainSeq = seq_data->main;
  int *matchSeq = seq_data->match;
  int gapExtend = sim_matrix->gapExtend;
  int gapFirst = sim_matrix->gapStart + gapExtend;
  int report = 0;
  int good_index = 0;
  int n = seq_data->mainLen;
  int m = seq_data->matchLen;

  int *V = malloc(seq_data->mainLen*sizeof(int));
  int *F = malloc(seq_data->matchLen*sizeof(int));

  int main_sequence, worst, W, G, E, Vp, compare_a, compare_b, i, j; 

  for(int idx = 0; idx < m; idx++)
  {
    V[idx] = 0;
    F[idx] = -gapFirst;
  }

  /* Loop over each codon in the mainSeq sequence, matching it with each codon   */
  /* in the matchSeq sequence, using the local-affine version of Smith-Waterman. */
  for(i=0; i<n; i++)
  {
    main_sequence=mainSeq[i];
    G = sim_matrix->similarity[main_sequence][matchSeq[0]];
    Vp = V[0];
    // Matlab has a builtin MAX function that can take arbitrary vectors, I have
    // to simulate that with compare_{a,b} and multiple compare.  
    compare_a = F[0] > G ? F[0] : G;
    V[0] = 0 > compare_a ? 0 : compare_a;
    F[0] = (F[0] - gapExtend > V[0] - gapFirst) ? F[0] - gapExtend : V[0] - gapFirst;
    E = V[0] - gapFirst;

    // match each mainSeq with each matchSeq codon to get a similarity weight
    for(j = 1; j < m; j++)
    {
      // match each mainSeq with each matchSeq codon to get a similarity weight
      W = sim_matrix->similarity[main_sequence][matchSeq[j]];
      // add the weight of the best match ending just before it
      G = Vp + W;
      // find the very best weight ending with this pair
      Vp = V[j]; // value of previous row
      // 4, we are comparing 4 values!  Ah ah!
      compare_a = 0 > E ? 0 : E;
      //compare_a = 0;
      compare_b = F[j] > compare_a ? F[j] : compare_a;
      V[j] = G > compare_b ? G : compare_b;
      //if(E > 0 && E > F[j] && E > G) printf("Bummer: E=%i, F[j]=%i, G=%i\n", E, F[j], G);
      // If score is good enough, this is an improvement, is not a skip,
      // and the next pair doesn't improve the match'
      if(V[j] >= minScore && W > 0 && V[j] == G && 
         (j == m-1 || i == n-1 || sim_matrix->similarity[mainSeq[i+1]][matchSeq[j+1]] <= 0))
      {
        // update goodScores/goodEnds
        considerAdding(V, &minScore, &report, minSeparation, i, j, sortReports, maxReports, working_good_ends, working_good_scores);
      }
      // find the best weight assuming a gap in mainSeq
      compare_a = E - gapExtend;
      compare_b = V[j] - gapFirst;
      E = compare_a > compare_b ? compare_a : compare_b;
      // find the best weight assuming a gap in matchSeq
      compare_a = F[j] - gapExtend;
      compare_b = V[j] - gapFirst;
      F[j] =  compare_a > compare_b ? compare_a : compare_b;
    }
  }

  memcpy(sort_array, working_good_scores, sortReports * sizeof(int));
  memset(index_array, 0, sizeof(int)*sortReports);
  index_sort(sort_array, index_array, report);
  compare_a = report - maxReports;
  worst = compare_a > 0 ? compare_a : 0;
  good_index = 0;
  for(int idx = report-1; idx >= worst; idx--)
  {
    answer->goodScores[good_index] = working_good_scores[index_array[idx]];
    answer->goodEnds[0][good_index] = working_good_ends[0][index_array[idx]];
    answer->goodEnds[1][good_index] = working_good_ends[1][index_array[idx]];
    good_index++;
  }

  free(V);
  free(F);
  free(working_good_scores);
  free(working_good_ends[0]);
  free(working_good_ends[1]);
  free(sort_array);
  free(index_array);
  answer->numReports = good_index;
  return answer;
}

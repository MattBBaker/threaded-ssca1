#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sort.h>
#include <gen_scal_data.h>

char validations[2][3][32] =
  {
    {"ACDEFG*IDENTICAL*HIKLMN", "ACDEFG*MISQRMATCHES*HIKLMN", "ACDEFG*STARTGAPMIDSTEND*HIKLMN"},
    {"MNLKIH*IDENTICAL*GFEDCA", "MNLKIH*MISRQMATCHES*GFEDCA", "MNLKIH*STARTMIDSTGAPEND*GFEDCA"}
  };

/* print the output */

void verifyData(sim_matrix_t *simMatrix, seq_data_t *seqData)
{
  printf("\n");
  printf("   Length of main sequence in codons: %i\n", seqData->mainLen);
  printf("  Length of match sequence in codons: %i\n", seqData->matchLen);
  printf("  Weight for exactly matching codons: %i\n", simMatrix->exact);
  printf("           Weight for similar codons: %i\n", simMatrix->similar);
  printf("        Weight for dissimilar codons: %i\n", simMatrix->dissimilar);
  printf("              Penalty to start a gap: %i\n", simMatrix->gapStart);
  printf("     Penalty for each codon in a gap: %i\n", simMatrix->gapExtend);
}

/* insert validation sequences at random points in the codon sequence */

unsigned long insert_validation(int *data_sequence[], unsigned long sequence_size, 
                                char strings_to_insert[][32], unsigned long string_vector_size, sim_matrix_t *simMatrix)
{
  int starting_points[string_vector_size], grow_vector=0, new_size, new_data_index=0;
  int source_index = 0, insertion_index = 0, string_length, not_done=1;
  int *new_data;
  int next_number=0;

  for(int i = 0; i < string_vector_size; i++)
  {
    grow_vector += strlen(strings_to_insert[i]);
  }
  new_size = grow_vector + sequence_size;
  new_data = (int *)malloc(sizeof(int)*new_size);

  // We may have to redo the random insertions if the starting points are not uniqe
  while(not_done)
  {
    not_done = 0;

    for(int i = 0; i < string_vector_size; i++)
    {
      starting_points[i] = rand()%sequence_size;
    }

    sort(starting_points, string_vector_size);
    // check the output
    next_number = starting_points[0];
    for(int idx=1; idx < string_vector_size; idx++)
    {
      if(next_number == starting_points[idx])
      {
        not_done = 1;
        break;
      }
      next_number = starting_points[idx];
    }
  }
  next_number = starting_points[0];
  while(new_data_index < new_size)
  {
    // no need for special checks after the last index is inserted, we just skip updating it
    if(next_number == source_index)
    {
      printf("Inserting string \"%s\" into location %i\n", strings_to_insert[insertion_index], new_data_index);
      string_length = strlen(strings_to_insert[insertion_index]);
      for(int j = 0; j < string_length; j++)
      {
        new_data[new_data_index] = simMatrix->encode[(int)strings_to_insert[insertion_index][j]];
        new_data_index++;
      }
      insertion_index++;
      if(insertion_index < string_vector_size)
        next_number = starting_points[insertion_index];
    }
    new_data[new_data_index] = (*data_sequence)[source_index];
    source_index++;
    new_data_index++;
  }
  /* just a reminder, we are freeing the memory in the pointer that the pointer data_sequence points to */
  free(*data_sequence); /* This is NOT a mistake */
  *data_sequence = new_data;
 
  return new_size;
}

/* gen_scal_data */
/* generates random codon sequences and inserts some validation sequences */
/* Input:
 *   sim_matrix_t simMatrix - sim_matrix_t generated by gen_sim_matrix()
 *   int mainLen            - the codon length of main
 *   int matchLen           - the codon length of match
 *
 * Output:
 *   seq_data_t *           - struct that holds the generated data sequences
 *      ->int *main         - array of ints representing the main codon sequence
 *      ->int *match        - array of ints representing the match codon sequence
 *      ->int maxValidation - the longest matching validation string
 *      ->int mainLen       - the length of the main sequence
 *      ->int matchLen      - the length of the match sequence
 */

seq_data_t *gen_scal_data( sim_matrix_t *simMatrix, int mainLen, int matchLen)
{
  seq_data_t *the_scal_data = (seq_data_t *)malloc(sizeof(seq_data_t));
  void *tester;
  int max_validation;

  the_scal_data->maxValidation = 0;
  the_scal_data->main = malloc(sizeof(int)*mainLen);
  the_scal_data->match = malloc(sizeof(int)*matchLen);

  for(int i=0; i < 2; i++)
  {
    for(int j=0; j < 3; j++)
    {
      max_validation = strlen(validations[i][j]);
      if(max_validation > the_scal_data->maxValidation)
        the_scal_data->maxValidation = max_validation;
    }
  }

  the_scal_data->maxValidation -= 12;

  for(int main_index = 0; main_index < mainLen; main_index++)
  {
    the_scal_data->main[main_index] = rand()%64;
  }
  for(int match_index = 0; match_index < matchLen; match_index++)
  {
    the_scal_data->match[match_index] = rand()%64;
  }

  tester = the_scal_data->main;
  the_scal_data->mainLen = insert_validation(&(the_scal_data->main), mainLen, validations[0], 3, simMatrix);
  the_scal_data->matchLen = insert_validation(&(the_scal_data->match), matchLen, validations[1], 3, simMatrix);

  /*  print_decoded(the_scal_data->main, mainLen, simMatrix); */

  return the_scal_data;
}

/* void release_scal_data(seq_data_t *doomed_seq)
 * releases the seq_data structure, returning the memory to the OS
 */

void release_scal_data(seq_data_t *doomed_seq)
{
  free((void *)(doomed_seq->main));
  free((void *)(doomed_seq->match));
  free((void *)doomed_seq);
}
